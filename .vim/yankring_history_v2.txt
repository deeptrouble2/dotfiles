/,v
./bundle/xterm-color-table.vim/.git,v
https://github.com/deeptrouble2/dotfiles,v
toggle_free,v
  [key] mod = { "Super" }   key = "f" func = "client_toggle_free" [/key],V
c,v
,V
          client_focus(c);,V
        || (c = client_gb_frame(W->last_clicked_barwin->win))),V
     if((c = client_gb_titlebar(W->last_clicked_barwin->win)),V
     struct client *c;,V
     (void)cmd;,V
     struct client *c;     (void)cmd;     if(!(W->client))          return;     W->client->flags ^= CLIENT_FREE;     layout_client(W->client);     /* Set tabbed client of toggled client as free */     if(W->client->flags & CLIENT_TABMASTER)     {          SLIST_FOREACH(c, &W->client->tag->clients, tnext)               if(c->tabmaster == W->client && c != W->client)                    c->flags ^= CLIENT_FREE;     },v
focus_click,v
voiduicb_client_focus_click(Uicb cmd){     (void)cmd;     struct client *c;     if((c = client_gb_titlebar(W->last_clicked_barwin->win))        || (c = client_gb_frame(W->last_clicked_barwin->win)))          client_focus(c);},v
void uicb_client_focus_click(Uicb);,V
tab_next_opened,v
     { "client_tab_next_opened",   uicb_client_tab_next_opened },,V
86400,v
3,v
            type uint32 { range "30..86400"; },V
*,v
reporters,v
        memset(intf->reporters, 0, sizeof(intf->reporters));,V
intf->is_rogue && ,v
is_terminating,v
unsanctioned,v
 ,V
            PICKLE_DICT_BOOL(pk, "is_interferer", ,V
),v
(,v
;intf->is_rogue) num_rogues++;,v
(intf->rssi*-1 >= rapcfg.rssi_threshold));,v
rogues,v
    int num_rogues = 0;    struct rapintf *intf = NULL;    int iter = -1;    while ((intf = iterate_intf(intf, &iter)) != NULL) {        if (intf->is_rogue) num_rogues++;    } ,v
            PICKLE_DICT_BOOL(pk, "is_interferer", (intf->rssi*-1 >= rapcfg.rssi_threshold));,V
static int num_interferers = 0;,V
static int num_rogues = 0;,V
count,v
channel == channel) count++;,v
struct rapintf *intf = NULL;    int iter = -1;    while ((intf = iterate_intf(intf, &iter)) != NULL) {        if (intf->channel == channel) count++;    },v
    struct rapintf *intf = NULL;    int iter = -1;,V
static int num_unsanctioned = 0;,V
    char *buffer = NULL;,V
v["count"][idx],v
				$(TOP)/src/sys/ssm/inc \,V
buffer[100];,v
, sizeof(buffer));,v
INCDIRS     +=  $(TOP)/src/sys/cc2/super ,V
$,v
(TOP)/src/sys/cc2/rim/inc \,V
$(TOP)/src/sys/ssm/inc \,v
                $(TOP)/src/sys/cc2/rim/inc \,V
$(TOP)/src/sys/cc2/rim/inc \,v
$(TOP)/src/sys/cc2/cryptlib \,v
				$(TOP)/src/sys/cc2/cryptlib \,V
               $(TOP)/src/sys/cc2/rim/inc \,V
#include "stats/mmi.h",V
s,v
    num_stats_intf = 0;,V
    struct rapintf *intf = NULL;    int iter = -1;    num_stats_intf = 0;    while ((intf = iterate_intf(intf, &iter)) != NULL) {,V
Too slow, fix this ,v
 {,v
size_t rap_pickle_channel_map(int channel, DOMAIN_POOL* domain, char** buffer) {,V
_,v
t,v
a,v
uint16_t,v
        return 0;.,V
.,v
 ,v
    },V
            counts++;.,V
        if (rap->channel == channel ),V
    for ( rap = domain->rap_hash.list_head; rap; rap = X2_NODE_OF_OBJ(rap, offset)->next ) {,V
    STATS_RAP *rap;,V
    int offset = offsetof(STATS_RAP, node)+offsetof(HASH_NODE, sort);,V
S,v
E,v
C,v
A,v
.....,v
// pickle apdetect,V
*/,v
       ,v
    /*,V
static int cmp_rap_proximity(const void *e1, const void *e2) {    const struct rap_proximity *one = (const struct rap_proximity *) e1;    const struct rap_proximity *two = (const struct rap_proximity *) e2;    if (one->rssi < two->rssi) return -1;    else if (one->rssi > two->rssi) return 1;    return 0;},v
static int start_termination(struct rapintf *intf) {    struct rap_proximity prox[RAP_MAX_REPORTER_ENTRIES];    int rcnt = 0;    // If termination is in progress and we already have enough terminators return    if (intf->term_active && (intf->term_count >= RAP_MAX_TERMINATORS)) return 1;    int was_active = intf->term_active;    for (int i=0;i<RAP_MAX_REPORTER_ENTRIES; i++) {        struct rap_data *rd = intf->reporters[i];        if (!rd) continue;         struct intf_rssi *ir = rssi_hash_find(rd, intf->mac);        if (!ir) continue;        prox[rcnt].rd = rd;        prox[rcnt].rssi = ir->rssi;        rcnt++;    }    qsort(&prox, rcnt, sizeof(prox[0]), cmp_rap_proximity);    // Send to top three reporters    MESSAGE_BUF sbuf;    uint8_t *posn = message_buf_init(&sbuf);    struct term_info *term = (struct term_info *)posn;    COPY_MAC(term->mac, intf->mac);    term->channel = intf->channel;    posn += sizeof(struct term_info);    sbuf.len = posn - sbuf.data;    struct rap_msg *msg = message_buf_push(&sbuf, sizeof(struct rap_msg));    msg->version = RAP_MSG_VERSION;    msg->mid = APDETECT_MESSAGE_TYPE_TERMINATE;    msg->length = htons(sbuf.len);    intf->term_count = 0;    for (int i=0; i<rcnt; i++) {        if (!prox[i].rd->is_terminating) {            RAP_INFO("Termination for "MACFORMAT" sent to %s", MAC2STR(intf->mac), prox[i].rd->hostname);            demux_send(prox[i].rd->device, sbuf.data, sbuf.len);            prox[i].rd->is_terminating = 1;            prox[i].rd->terminated = intf;            intf->term_active = 1;            intf->terminators[intf->term_count] = prox[i].rd;            intf->term_count++;        }        // Use at the most RAP_MAX_TERMINATORS for termination        if (intf->term_count >= RAP_MAX_TERMINATORS) break;    }    // Raise an event if we just went active    if (!was_active && (intf->term_count > 0)) {        WING_EVENT(AIR_TERMINATION_INITIATED, intf->mac, mac2vendor(intf->mac), intf->channel);    }    return (intf->term_count > 0);},v
 = 0;,v
)),v
    rapcfg.air_term_auto = 0;,V
^i[right;0;0;/home/deepak/.config/wmfs/icons/status/fox.png]^s[right;\#D8ADFF; ${nodename}]\,v
left,v
FF95D1,v
hostname,v
},v
1,v
m,v
e,v
p,v
